<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Callbacks · BlockDecomposition</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/highlightjs/default.css" rel="stylesheet" type="text/css"/><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>BlockDecomposition</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li><a class="toctext" href="installation.html">Installation</a></li><li><a class="toctext" href="introduction.html">Introduction</a></li><li><a class="toctext" href="basic.html">Basic</a></li><li class="current"><a class="toctext" href="callbacks.html">Callbacks</a><ul class="internal"><li><a class="toctext" href="#Introduction-1">Introduction</a></li><li><a class="toctext" href="#Write-the-oracle-solver-1">Write the oracle solver</a></li><li><a class="toctext" href="#Attach-the-oracle-solver-1">Attach the oracle solver</a></li></ul></li><li><a class="toctext" href="advanced.html">Advanced</a></li><li><a class="toctext" href="BlockSolverInterface.html">BlockSolverInterface</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="callbacks.html">Callbacks</a></li></ul><a class="edit-page" href="https://github.com/realopt/BlockDecomposition.jl/tree/a36adb3de75462f6e550a2e793580b16eefc65d4/docs/src/callbacks.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Callbacks</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Callbacks-1" href="#Callbacks-1">Callbacks</a></h1><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>No solver over Julia supports this feature yet.</p></div></div><p>Oracles are customized solvers that can be used to solve efficiently subproblems. We introduce them using the example of Generalized Assignment Problem.</p><h2><a class="nav-anchor" id="Introduction-1" href="#Introduction-1">Introduction</a></h2><p>Cosider a set of machines <code>Machines = 1:M</code> and a set of jobs <code>Jobs = 1:J</code>. A machine <code>m</code> has a resource capacity <code>Capacity[m]</code>. When we assign a job <code>j</code> to a machine <code>m</code>, the job has a cost <code>Cost[m,j]</code> and consumes <code>Weight[m,j]</code> resources of the machine <code>m</code>. The goal is to minimize the jobs cost sum by assigning each job to a machine while not exceeding the capacity of each machine. The model is</p><pre><code class="language-julia">gap = BlockModel(solver = solver)

@variable(gap, x[m in Machines, j in Jobs], Bin)

@constraint(gap, cov[0, j in Jobs],
               sum{ x[m,j], m in Machines } &gt;= 1)

@constraint(gap, knp[m in Machines],
               sum{Weight[m,j]*x[m,j], j in Jobs} &lt;= Capacity[m])

@objective(gap, Min,
               sum{Cost[m,j]*x[m,j], m in Machines, j in Jobs})

function dw_fct(cstrname::Symbol, cstrid::Tuple) :: Tuple{Symbol, Tuple}
    if cstrname == :cov           # cov constraints will be assigned in the
        return (:DW_MASTER, (0,)) # master that has the index 0
    else                          # others constraints will be assigned in a
        return (:DW_SP, cstrid)   # subproblem with same index as the constraint
    end
end
add_Dantzig_Wolfe_decomposition(gap, dw_fct)</code></pre><p>Generalized Assignment problem can be solved using a Dantzig-Wolfe decomposition. Imagine we have a julia function that can solve efficiently the knapsack problem and returns the solution and the value of the solution</p><pre><code class="language-julia">(sol,value) = solveKnp(costs::Vector{Float64}, weights::Vector{Integer}, capacity::Integer)</code></pre><h2><a class="nav-anchor" id="Write-the-oracle-solver-1" href="#Write-the-oracle-solver-1">Write the oracle solver</a></h2><p>We define an oracle that calls this function and solves each knapsack subproblem. ::</p><pre><code class="language-julia">function myKnapsackSolver(od::OracleSolverData)
    machine = getspid(od)[0] # get the machine index
    costs = [getcurcost(x[machine,j]) for j in Jobs] # get the current cost
    (sol_x_m, value) = solveKnp(costs, Weight[m,:], Capacity[m]) # call the solver

    # Building the oracle solution
    for j in data.jobs
        # add to oracle solution variables x[machine,j] with values sol_x_m[j]
        setsolutionvalue(od, x[machine,j], sol_x_m[j])
    end

    # Set the objective value of the solution
    setsolutionbestobjval(od, value)
end</code></pre><p>In this code, we use the four main functions for oracles provided by BlockDecomposition.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlockDecomposition.getspid" href="#BlockDecomposition.getspid"><code>BlockDecomposition.getspid</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">getspid(data::OracleSolverData)</code></pre><p>Returns the subproblem index for which the oracle has been assigned.</p></div><a class="source-link" target="_blank" href="https://github.com/realopt/BlockDecomposition.jl/tree/a36adb3de75462f6e550a2e793580b16eefc65d4/src/bjoracles.jl#L129-L133">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlockDecomposition.getcurcost" href="#BlockDecomposition.getcurcost"><code>BlockDecomposition.getcurcost</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">getcurcost(x::JuMP.Variable)</code></pre><p>Returns the current cost of the varibale <code>x</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/realopt/BlockDecomposition.jl/tree/a36adb3de75462f6e550a2e793580b16eefc65d4/src/bjoracles.jl#L80-L84">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.setsolutionvalue" href="#JuMP.setsolutionvalue"><code>JuMP.setsolutionvalue</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">setsolutionvalue!(data::OracleSolverData, x, val::Real)</code></pre><p>Assigns the value <code>val</code> to the variable <code>x</code> in the solution of the oracle solver</p></div><a class="source-link" target="_blank" href="https://github.com/realopt/BlockDecomposition.jl/tree/a36adb3de75462f6e550a2e793580b16eefc65d4/src/bjoracles.jl#L52-L57">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlockDecomposition.setsolutionbestobjval" href="#BlockDecomposition.setsolutionbestobjval"><code>BlockDecomposition.setsolutionbestobjval</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">setsolutionbestobjval!(data::OracleSolverData, objval::Real)</code></pre><p>Assigns the value <code>value</code> to the variable <code>x</code> in the solution of the oracle solver</p></div><a class="source-link" target="_blank" href="https://github.com/realopt/BlockDecomposition.jl/tree/a36adb3de75462f6e550a2e793580b16eefc65d4/src/bjoracles.jl#L66-L71">source</a><br/></section><h2><a class="nav-anchor" id="Attach-the-oracle-solver-1" href="#Attach-the-oracle-solver-1">Attach the oracle solver</a></h2><p>Once the oracle solver function defined, we assign it to some subproblems using the following function.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlockDecomposition.addoracletosp!" href="#BlockDecomposition.addoracletosp!"><code>BlockDecomposition.addoracletosp!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">addoracletosp!(model::JuMP.Model, sp_id, sp_type::Symbol, f::Function)</code></pre><p>Attaches the oracle <code>f</code> to the subproblem of type <code>sp_type</code> which has the index <code>spid</code>. The argument <code>spid</code> must be a  <code>Tuple</code> or an  <code>Integer</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/realopt/BlockDecomposition.jl/tree/a36adb3de75462f6e550a2e793580b16eefc65d4/src/bjoracles.jl#L17-L22">source</a><br/></section><p>In our example, we do</p><pre><code class="language-julia">for m in data.machines
    addoracletosp!(gap, m, myKnapsackSolver)
end</code></pre><footer><hr/><a class="previous" href="basic.html"><span class="direction">Previous</span><span class="title">Basic</span></a><a class="next" href="advanced.html"><span class="direction">Next</span><span class="title">Advanced</span></a></footer></article></body></html>
