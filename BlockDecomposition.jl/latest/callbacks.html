<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Callbacks · BlockDecomposition</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>BlockDecomposition</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li><a class="toctext" href="installation.html">Installation</a></li><li><a class="toctext" href="introduction.html">Introduction</a></li><li><a class="toctext" href="basic.html">Basic</a></li><li class="current"><a class="toctext" href="callbacks.html">Callbacks</a><ul class="internal"><li><a class="toctext" href="#Introduction-1">Introduction</a></li><li><a class="toctext" href="#Write-the-oracle-solver-1">Write the oracle solver</a></li><li><a class="toctext" href="#Attach-the-oracle-solver-1">Attach the oracle solver</a></li></ul></li><li><a class="toctext" href="advanced.html">Advanced</a></li><li><a class="toctext" href="BlockSolverInterface.html">BlockSolverInterface</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="callbacks.html">Callbacks</a></li></ul><a class="edit-page" href="https://github.com/realopt/BlockDecomposition.jl/blob/master/docs/src/callbacks.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Callbacks</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Callbacks-1" href="#Callbacks-1">Callbacks</a></h1><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>No solver over Julia supports this feature yet.</p></div></div><p>Oracles are customized solvers that can be used to solve efficiently subproblems. We introduce them using the example of Generalized Assignment Problem.</p><h2><a class="nav-anchor" id="Introduction-1" href="#Introduction-1">Introduction</a></h2><p>Consider a set of machines <code>Machines = 1:M</code> and a set of jobs <code>Jobs = 1:J</code>. A machine <code>m</code> has a resource capacity <code>Capacity[m]</code>. When we assign a job <code>j</code> to a machine <code>m</code>, the job has a cost <code>Cost[m,j]</code> and consumes <code>Weight[m,j]</code> resources of the machine <code>m</code>. The goal is to minimize the jobs cost sum by assigning each job to a machine while not exceeding the capacity of each machine. The model is</p><pre><code class="language-julia">gap = BlockModel(solver = solver)

@variable(gap, x[m in Machines, j in Jobs], Bin)

@constraint(gap, cov[0, j in Jobs],
               sum(x[m,j] for m in Machines) &gt;= 1)

@constraint(gap, knp[m in Machines],
               sum(Weight[m,j]*x[m,j] for j in Jobs) &lt;= Capacity[m])

@objective(gap, Min,
               sum(Cost[m,j]*x[m,j] for m in Machines, j in Jobs))

function dw_fct(cstrname::Symbol, cstrid::Tuple) :: Tuple{Symbol, Tuple}
    if cstrname == :cov           # cov constraints will be assigned in the
        return (:DW_MASTER, (0,)) # master that has the index 0
    else                          # others constraints will be assigned in a
        return (:DW_SP, cstrid)   # subproblem with same index as the constraint
    end
end
add_Dantzig_Wolfe_decomposition(gap, dw_fct)</code></pre><p>Generalized Assignment problem can be solved using a Dantzig-Wolfe decomposition. Imagine we have a julia function that can solve efficiently the knapsack problem and returns the solution and the value of the solution</p><pre><code class="language-julia">(sol,value) = solveKnp(costs::Vector{Float64}, weights::Vector{Integer}, capacity::Integer)</code></pre><h2><a class="nav-anchor" id="Write-the-oracle-solver-1" href="#Write-the-oracle-solver-1">Write the oracle solver</a></h2><p>We define an oracle that calls this function and solves each knapsack subproblem. ::</p><pre><code class="language-julia">function myKnapsackSolver(od::OracleSolverData)
    machine = getspid(od)[0] # get the machine index
    costs = [getcurcost(x[machine,j]) for j in Jobs] # get the current cost
    (sol_x_m, value) = solveKnp(costs, Weight[m,:], Capacity[m]) # call the solver

    # Building the oracle solution
    for j in data.jobs
        # add to oracle solution variables x[machine,j] with values sol_x_m[j]
        setsolutionvalue(od, x[machine,j], sol_x_m[j])
    end

    # Set the objective value of the solution
    setsolutionbestobjval(od, value)
end</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlockDecomposition.getspid" href="#BlockDecomposition.getspid"><code>BlockDecomposition.getspid</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">getspid(data::OracleSolverData)</code></pre><p>Returns the subproblem index for which the oracle has been assigned.</p></div><a class="source-link" target="_blank" href="https://github.com/realopt/BlockDecomposition.jl/blob/825a7961e3ead63c25f20f581d7be16786f8a04b/src/bjoracles.jl#L129-L133">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlockDecomposition.getcurcost" href="#BlockDecomposition.getcurcost"><code>BlockDecomposition.getcurcost</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">getcurcost(x::JuMP.Variable)</code></pre><p>Returns the current cost of the varibale <code>x</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/realopt/BlockDecomposition.jl/blob/825a7961e3ead63c25f20f581d7be16786f8a04b/src/bjoracles.jl#L80-L84">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlockDecomposition.getcurub" href="#BlockDecomposition.getcurub"><code>BlockDecomposition.getcurub</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">getcurub(x::JuMP.Variable)</code></pre><p>Returns the current ub of the varibale <code>x</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/realopt/BlockDecomposition.jl/blob/825a7961e3ead63c25f20f581d7be16786f8a04b/src/bjoracles.jl#L92-L96">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlockDecomposition.getcurlb" href="#BlockDecomposition.getcurlb"><code>BlockDecomposition.getcurlb</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">getcurlb(x::JuMP.Variable)</code></pre><p>Returns the current lb of the varibale <code>x</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/realopt/BlockDecomposition.jl/blob/825a7961e3ead63c25f20f581d7be16786f8a04b/src/bjoracles.jl#L104-L108">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlockDecomposition.getcurdual" href="#BlockDecomposition.getcurdual"><code>BlockDecomposition.getcurdual</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">getcurdual(x::JuMP.Constraint)</code></pre><p>Returns the current dual of the constraint <code>x</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/realopt/BlockDecomposition.jl/blob/825a7961e3ead63c25f20f581d7be16786f8a04b/src/bjoracles.jl#L117-L121">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.setsolutionvalue" href="#JuMP.setsolutionvalue"><code>JuMP.setsolutionvalue</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">setsolutionvalue!(data::OracleSolverData, x, val::Real)</code></pre><p>Assigns the value <code>val</code> to the variable <code>x</code> in the solution of the oracle solver</p></div><a class="source-link" target="_blank" href="https://github.com/realopt/BlockDecomposition.jl/blob/825a7961e3ead63c25f20f581d7be16786f8a04b/src/bjoracles.jl#L52-L57">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlockDecomposition.setsolutionbestobjval" href="#BlockDecomposition.setsolutionbestobjval"><code>BlockDecomposition.setsolutionbestobjval</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">setsolutionbestobjval!(data::OracleSolverData, objval::Real)</code></pre><p>Assigns the value <code>value</code> to the variable <code>x</code> in the solution of the oracle solver</p></div><a class="source-link" target="_blank" href="https://github.com/realopt/BlockDecomposition.jl/blob/825a7961e3ead63c25f20f581d7be16786f8a04b/src/bjoracles.jl#L66-L71">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.addsolution" href="#JuMP.addsolution"><code>JuMP.addsolution</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">addsolution(data::OracleSolverData)</code></pre><p>It ends the current solution and create a new solution in the oracle solver solution. Note that the previous solutions cannot be modified anymore.</p></div><a class="source-link" target="_blank" href="https://github.com/realopt/BlockDecomposition.jl/blob/825a7961e3ead63c25f20f581d7be16786f8a04b/src/bjoracles.jl#L38-L43">source</a></section><h2><a class="nav-anchor" id="Attach-the-oracle-solver-1" href="#Attach-the-oracle-solver-1">Attach the oracle solver</a></h2><p>Once the oracle solver function defined, we assign it to some subproblems using the following function.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BlockDecomposition.addoracletosp!" href="#BlockDecomposition.addoracletosp!"><code>BlockDecomposition.addoracletosp!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">addoracletosp!(model::JuMP.Model, sp_id, sp_type::Symbol, f::Function)</code></pre><p>Attaches the oracle <code>f</code> to the subproblem of type <code>sp_type</code> which has the index <code>spid</code>. The argument <code>spid</code> must be a  <code>Tuple</code> or an  <code>Integer</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/realopt/BlockDecomposition.jl/blob/825a7961e3ead63c25f20f581d7be16786f8a04b/src/bjoracles.jl#L17-L22">source</a></section><p>In our example, for each subproblem with <code>m</code>, we assign the oracle <code>myKnapsackSolver</code>.</p><pre><code class="language-julia">for m in data.machines
    addoracletosp!(gap, m, myKnapsackSolver)
end</code></pre><footer><hr/><a class="previous" href="basic.html"><span class="direction">Previous</span><span class="title">Basic</span></a><a class="next" href="advanced.html"><span class="direction">Next</span><span class="title">Advanced</span></a></footer></article></body></html>
